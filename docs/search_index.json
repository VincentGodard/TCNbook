[["application-to-denudation-rate-measurements.html", "6 Application to denudation rate measurements 6.1 Concentration - denudation rate relationship 6.2 Integration time scale 6.3 Catchment wide denudation rates 6.4 Change in denudation through time 6.5 On the importance of muons", " 6 Application to denudation rate measurements 6.1 Concentration - denudation rate relationship Now we are going to consider the evolution of concentration with denudation rate \\(\\varepsilon\\). The computation will be carried out at the surface (\\(z=0\\)), but this could be done at any arbitrary depth. We will consider that \\(t=+\\infty\\) and that we have reached the plateau concentration. Equation (??) becomes, \\[\\begin{equation} C=\\sum_i \\frac{P_i}{\\frac{\\rho \\varepsilon}{\\Lambda_i}+\\lambda} \\tag{6.1} \\end{equation}\\] Which simplifies to \\(C\\approx\\frac{P_i \\Lambda_i}{\\rho \\varepsilon}\\) if we neglect radioactive decay. We define the usual parameters. Code altitude = 1000 # elevation in m latitude = 45 # latitude in degrees rho = 2.7 data(prm) data(Lambda) P = atm_pressure(alt=altitude,model=&quot;stone2000&quot;) # compute atmospheric pressure at site S = scaling_st(P,latitude) # compute the scaling parameters according to Stone (2000) Now compute the steady-state concentration for a range of denudation rates. Code nuc = &quot;Be10&quot; ero = 10^seq(log10(0.1),log10(1000),length.out = 100) * 100/1e6*rho # a log-spaced vector for denudation rate expressed in m/Ma and converted in g/cm2/a age = Inf # infinite age z = 0 * rho # depth at which we are going to perform the calculation (cm converted to g/cm2) C0 = 0 # inherited concentration C = solv_conc_eul(z,ero,age,C0,prm[,nuc],S,Lambda) # compute concentration We plot the result, and also consider consider the implications of neglecting the radioactive decay. Code plot(ero/100*1e6/rho,C,col=&quot;lawngreen&quot;,log=&quot;xy&quot;,type=&quot;l&quot;,lwd=3,ylab=&quot;Concentration (at/g)&quot;,xlab=&quot;Denudation rate (m/Ma)&quot;) # what happens if we neglect radioactive decay Prod = c(prm[1,nuc]*S$Nneutrons,prm[2,nuc]*S$Nmuons,prm[3,nuc]*S$Nmuons) # scaled production vector (defined for the sake of clarity of the expressions) lambda = prm[4,nuc] # radioactive decay C2 = sum(Prod*Lambda)/ero lines(ero/100*1e6/rho,C2,lty=2) Below you can get all the necessary code to produce the figure Code library(&quot;TCNtools&quot;) altitude = 1000 # elevation in m latitude = 45 # latitude in degrees rho = 2.7 data(prm) data(Lambda) P = atm_pressure(alt=altitude,model=&quot;stone2000&quot;) # compute atmospheric pressure at site S = scaling_st(P,latitude) # compute the scaling parameters according to Stone (2000) nuc = &quot;Be10&quot; ero = 10^seq(log10(0.1),log10(1000),length.out = 100) * 100/1e6*rho # a log-spaced vector for denudation rate expressed in m/Ma and converted in g/cm2/a age = Inf # infinite age z = 0 * rho # depth at which we are going to perform the calculation (cm converted to g/cm2) C0 = 0 # inherited concentration C = solv_conc_eul(z,ero,age,C0,prm[,nuc],S,Lambda) # compute concentration plot(ero/100*1e6/rho,C,col=&quot;lawngreen&quot;,log=&quot;xy&quot;,type=&quot;l&quot;,lwd=3,ylab=&quot;Concentration (at/g)&quot;,xlab=&quot;Denudation rate (m/Ma)&quot;) # what happens if we neglect radioactive decay Prod = c(prm[1,nuc]*S$Nneutrons,prm[2,nuc]*S$Nmuons,prm[3,nuc]*S$Nmuons) # scaled production vector (defined for the sake of clarity of the expressions) lambda = prm[4,nuc] # radioactive decay C2 = sum(Prod*Lambda)/ero lines(ero/100*1e6/rho,C2,lty=2) This figure (log-scales on both axes) highlights the strong inverse relationship, at steady-state, between denudation rate (\\(\\varepsilon\\)) and concentration (\\(C\\)), which is the foundation of many geomorphological studies trying to establish landscape evolution rates. Note the change in the relationship at very low denudation rates, which corresponds to the situation where the effects of radioactive decay become predominant. Over what range of denudation rates it is reasonable to neglect radioactive decay? What kind of geological context could it correspond to? A simple way to answer this question would be to compute the relative difference between the computed concentrations Code error = abs(C-C2)/C*100 plot(ero/100*1e6/rho,error,log=&quot;xy&quot;,type=&quot;l&quot;,ylab=&quot;Relative error (%)&quot;,xlab=&quot;Denudation rate (m/Ma)&quot;) 6.2 Integration time scale Like all techniques used to measure erosion or denudation of the Earth surface, rates measured from cosmogenic nuclides are averaged over a specific period of time. This integration time-scale is often considered, at first order, to be the time required to erode the thickness of the zone where most of nuclide production occurs (von Blanckenburg (2005)), which can be considered as the penetration length for neutrons \\(\\Lambda/\\rho\\). This average is one of the advantages of the method, allowing to filter the high frequency variability, in particular of anthropic origin (Reusser, Bierman, and Rood (2015)). In its simplest form the integration time scale \\(\\tau\\) for a denudation rate measurement can be calculated as, \\[\\begin{equation} \\tau = \\frac{\\Lambda}{\\rho \\varepsilon} \\end{equation}\\] Code rho = 2.7 data(Lambda) ero = 10^seq(log10(0.5),log10(2000),length.out = 100) # log spaced vector for denudation rate mm/ka tau = (Lambda[1]/rho*10)/ero plot(ero,tau,xlab=&quot;Denudation rate (mm/ka)&quot;,ylab=&quot;Integration time scale (ka)&quot;,type=&quot;l&quot;,log=&quot;xy&quot;,lwd=3,col=&quot;gold&quot;) This simple plot allows to observe the very strong influence of denudation rate \\(\\varepsilon\\) on the integration time scale. For a denudation rate of 10 mm/ka, typical of slow erosion cratonic domains, the integration time scale is ~60 ka For a denudation rate of 500 mm/ka, which can be encountered in high relief mountain ranges, the integration time scale is ~1 ka What are the implications of this relationship for the geomorphological interpretation of the denudation rates? 6.3 Catchment wide denudation rates It can be noted that when dealing with eroding bedrock surfaces the calculated denudation rate will be a very local estimate and that its extrapolation to longer wavelengths is only possible in the rather limited cases where the morphological properties of the relief are uniform over large distances (plateaus, morphological surfaces, etc â€¦). In reality, in complex environments, such as mountain ranges, where several processes contribute to denudation, a simple local estimate does not provide really useful information on the overall dynamics of the topography. An alternative approach is to use river sediments, which are a mixture of contributions from different parts of a watershed. The measurement of a cosmogenic nuclide concentration in this type of sample provides an estimate of the average denudation over the corresponding basin (Brown et al. (1995),Granger, Kirchner, and Finkel (1996),von Blanckenburg (2005)). Calculating such average denudation rate requires to obtain an average production rate for the catchment. For low relief catchments the scaling parameters can be calculated using the average elevation of the catchment. But for catchments with several 1000s m in relief, the non linear relationship between the scaling parameters and elevation will make this approximation invalid. We are going to explore these ideas using 3 basins from the study of Godard et al. (2012) in the Marsyandi river basin (central Nepal) Here are the maps for these 3 basins. We are going to load the corresponding data as dataframes (x, y, z), either from the disk or directly from the github repository (path_to_data indicates where to look for the data). Code #path_to_data = &quot;data/gis/&quot; path_to_data =&quot;https://raw.githubusercontent.com/VincentGodard/TCNbook/main/data/gis/&quot; # we download directly from the github repository names_basins = c(&quot;Marsyandi&quot;,&quot;Chudi&quot;,&quot;Khudi&quot;) cols = c(&quot;deepskyblue&quot;, &quot;khaki3&quot;, &quot;darkolivegreen3&quot;) basins = list() # we store the dataframe into a list object for (i in 1:length(names_basins)){ basins[[i]] = read.table(paste0(path_to_data,names_basins[i],&quot;.dat&quot;),header=T) } We now plot the distribution of elevation for the 3 basins. Code # for (i in 1:length(names_basins)){ if (i == 1){ # we initiate a plot at the first iteration plot(density(basins[[i]]$z),ylim=c(0,0.0022),xlab=&quot;Elevation (m)&quot;,col=cols[i],main=&quot;&quot;) }else{ # then add the following basins as lines on the initial plot lines(density(basins[[i]]$z),col=cols[i]) } } legend(&quot;topright&quot;,names_basins,cex=0.5,lty=1,col=cols) Compare the distributions of elevation, and their position across the Himalayan range. How is this going to impact the determination of an average production rate for the basin? We then compute the st scaling parameters for each pixel (lines in the dataframes). Code for (i in 1:length(names_basins)){ basins[[i]]$P = atm_pressure(alt=basins[[i]]$z,model=&quot;stone2000&quot;) st = scaling_st(basins[[i]]$P,basins[[i]]$y) basins[[i]] = cbind(basins[[i]],st) } We plot the distribution of the spallation scaling factor for each basin. Code # plotting result for (i in 1:length(names_basins)){ if (i == 1){ # we initiate a plot at the first iteration plot(density(basins[[i]]$Nneutrons),ylim=c(1e-4,2.5),xlab=&quot;Spallation scaling factor&quot;,col=cols[i],main=&quot;&quot;,log=&quot;y&quot;) }else{ lines(density(basins[[i]]$Nneutrons),col=cols[i]) } } legend(&quot;topright&quot;,names_basins,cex=0.5,lty=1,col=cols) We now compute average values for the scaling paramters, in 2 different ways, 1 : We compute the scaling at each pixel according to its latitude and altitude (as we did above), and then take the average over the basin 2 : we compute the average latitude and altitude of the basin, and then use these average values to compute the scaling factors We create a dataframe res to store the results. Code res = data.frame(names=names_basins) # dataframe to store the results res$S1 = NA res$S2 = NA res$relief = NA for (i in 1:nrow(res)){ res$relief[i] = max(basins[[i]]$z) - min(basins[[i]]$z) # res$S1[i] = mean(basins[[i]]$Nneutrons) # P2 = atm_pressure(alt=mean(basins[[i]]$z),model=&quot;stone2000&quot;) st = scaling_st(P2,mean(basins[[i]]$y)) res$S2[i] = st$Nneutrons } print(res) ## names S1 S2 relief ## 1 Marsyandi 12.663441 9.444905 7676.423 ## 2 Chudi 1.420476 1.403903 1220.326 ## 3 Khudi 5.841666 5.168450 4065.374 We can visualize the difference between the two approaches. Code plot(res$S2,res$S1,pch=21,bg=cols, xlab=&quot;S2 : Scaling from average elevation&quot;,ylab=&quot;S1 : Scaling pixel by pixel&quot;, xlim=range(0,res$S2,res$S1),ylim=range(0,res$S2,res$S1)) grid() text(res$S2,res$S1,res$names,cex=0.5,pos=1) abline(0,1,lty=2) Below you can get all the necessary code to produce the figures presented in this section Code library(&quot;TCNtools&quot;) #path_to_data = &quot;data/gis/&quot; path_to_data =&quot;https://raw.githubusercontent.com/VincentGodard/TCNbook/main/data/gis/&quot; # we download directly from the github repository names_basins = c(&quot;Marsyandi&quot;,&quot;Chudi&quot;,&quot;Khudi&quot;) cols = c(&quot;deepskyblue&quot;, &quot;khaki3&quot;, &quot;darkolivegreen3&quot;) basins = list() # we store the dataframe into a list object for (i in 1:length(names_basins)){ basins[[i]] = read.table(paste0(path_to_data,names_basins[i],&quot;.dat&quot;),header=T) } # for (i in 1:length(names_basins)){ if (i == 1){ # we initiate a plot at the first iteration plot(density(basins[[i]]$z),ylim=c(0,0.0022),xlab=&quot;Elevation (m)&quot;,col=cols[i],main=&quot;&quot;) }else{ # then add the following basins as lines on the initial plot lines(density(basins[[i]]$z),col=cols[i]) } } legend(&quot;topright&quot;,names_basins,cex=0.5,lty=1,col=cols) for (i in 1:length(names_basins)){ basins[[i]]$P = atm_pressure(alt=basins[[i]]$z,model=&quot;stone2000&quot;) st = scaling_st(basins[[i]]$P,basins[[i]]$y) basins[[i]] = cbind(basins[[i]],st) } # plotting result for (i in 1:length(names_basins)){ if (i == 1){ # we initiate a plot at the first iteration plot(density(basins[[i]]$Nneutrons),ylim=c(1e-4,2.5),xlab=&quot;Spallation scaling factor&quot;,col=cols[i],main=&quot;&quot;,log=&quot;y&quot;) }else{ lines(density(basins[[i]]$Nneutrons),col=cols[i]) } } legend(&quot;topright&quot;,names_basins,cex=0.5,lty=1,col=cols) res = data.frame(names=names_basins) # dataframe to store the results res$S1 = NA res$S2 = NA res$relief = NA for (i in 1:nrow(res)){ res$relief[i] = max(basins[[i]]$z) - min(basins[[i]]$z) # res$S1[i] = mean(basins[[i]]$Nneutrons) # P2 = atm_pressure(alt=mean(basins[[i]]$z),model=&quot;stone2000&quot;) st = scaling_st(P2,mean(basins[[i]]$y)) res$S2[i] = st$Nneutrons } print(res) plot(res$S2,res$S1,pch=21,bg=cols, xlab=&quot;S2 : Scaling from average elevation&quot;,ylab=&quot;S1 : Scaling pixel by pixel&quot;, xlim=range(0,res$S2,res$S1),ylim=range(0,res$S2,res$S1)) grid() text(res$S2,res$S1,res$names,cex=0.5,pos=1) abline(0,1,lty=2) Comment on the differences. What are the other parameters which can influence the calculation of average production rates at the scale of a basin? 6.4 Change in denudation through time 6.5 On the importance of muons For \\(^{10}\\)Be the muonic represent a very small fraction of surface production : Code nuc = &quot;Be10&quot; f = (prm[2,nuc]+prm[3,nuc])/sum(prm[1:3,nuc])*100 paste(&quot;For&quot;,nuc,&quot;muons represent&quot;,round(f,1),&quot;% of SLHL surface production&quot;) ## [1] &quot;For Be10 muons represent 1.3 % of SLHL surface production&quot; Muons provide a a very small fraction of production at the surface for \\(^{10}\\)Be, but they penetrate much deeper than neutrons into rocks. For that reason they are going to account to a higher proportion of nuclides on eroding surfaces. We can separate the various sources of production (neutrons and muons) and see what is their respective contributions to the concentration observed at the surface. Code col_sp = &quot;deepskyblue&quot; col_sm = &quot;indianred1&quot; col_fm = &quot;darkseagreen1&quot; nuc = &quot;Be10&quot; data = data.frame(ero1=10^seq(log10(0.1),log10(2000),length=100)) # ero1 -&gt; denudation in m/Ma emin = min(data$ero1) emax = max(data$ero1) data$ero2 = data$ero1/1e6*100*rho # ero2 = denudation in g/cm2/a # steady state concentrations associated with individual production pathways data$Csp = prm[1,nuc]*S$Nneutrons/(prm[4,nuc]+(data$ero2/Lambda[1])) data$Csm = prm[2,nuc]*S$Nmuons/(prm[4,nuc]+(data$ero2/Lambda[2])) data$Cfm = prm[3,nuc]*S$Nmuons/(prm[4,nuc]+(data$ero2/Lambda[3])) data$C = data$Csp + data$Csm + data$Cfm # plot(NA,xlim=c(emin,emax),ylim=c(0,1),log=&quot;x&quot;,xlab=&quot;Denudation rate (m/Ma)&quot;,ylab=&quot;Fraction&quot;,xaxs=&quot;i&quot;,yaxs=&quot;i&quot;) polygon(c(emin,emax,emax,emin),c(0,0,1,1),col=col_fm) polygon(c(emin,emax,rev(data$ero1)), c(0,0,rev((data$Csp+data$Csm)/data$C)),col=col_sm) polygon(c(emin,emax,rev(data$ero1)), c(0,0,rev(data$Csp/data$C)),col=col_sp) grid(col=&quot;black&quot;,equilogs = FALSE) # text(0.2,0.1,nuc,cex=2) legend(&quot;bottomright&quot;, c(&quot;Spallation&quot;,&quot;Stopping muons&quot;,&quot;Fast muons&quot;), pch=22,pt.bg=c(col_sp,col_sm,col_fm),pt.cex=1.5,cex=1,bg=&quot;white&quot;) Below you can get all the necessary code to produce the figure Code library(&quot;TCNtools&quot;) altitude = 1000 # elevation in m latitude = 45 # latitude in degrees rho = 2.7 data(prm) data(Lambda) P = atm_pressure(alt=altitude,model=&quot;stone2000&quot;) # compute atmospheric pressure at site S = scaling_st(P,latitude) # compute the scaling parameters according to Stone (2000) col_sp = &quot;deepskyblue&quot; col_sm = &quot;indianred1&quot; col_fm = &quot;darkseagreen1&quot; nuc = &quot;Be10&quot; data = data.frame(ero1=10^seq(log10(0.1),log10(2000),length=100)) # ero1 -&gt; denudation in m/Ma emin = min(data$ero1) emax = max(data$ero1) data$ero2 = data$ero1/1e6*100*rho # ero2 = denudation in g/cm2/a # steady state concentrations associated with individual production pathways data$Csp = prm[1,nuc]*S$Nneutrons/(prm[4,nuc]+(data$ero2/Lambda[1])) data$Csm = prm[2,nuc]*S$Nmuons/(prm[4,nuc]+(data$ero2/Lambda[2])) data$Cfm = prm[3,nuc]*S$Nmuons/(prm[4,nuc]+(data$ero2/Lambda[3])) data$C = data$Csp + data$Csm + data$Cfm # plot(NA,xlim=c(emin,emax),ylim=c(0,1),log=&quot;x&quot;,xlab=&quot;Denudation rate (m/Ma)&quot;,ylab=&quot;Fraction&quot;,xaxs=&quot;i&quot;,yaxs=&quot;i&quot;) polygon(c(emin,emax,emax,emin),c(0,0,1,1),col=col_fm) polygon(c(emin,emax,rev(data$ero1)), c(0,0,rev((data$Csp+data$Csm)/data$C)),col=col_sm) polygon(c(emin,emax,rev(data$ero1)), c(0,0,rev(data$Csp/data$C)),col=col_sp) grid(col=&quot;black&quot;,equilogs = FALSE) # text(0.2,0.1,nuc,cex=2) legend(&quot;bottomright&quot;, c(&quot;Spallation&quot;,&quot;Stopping muons&quot;,&quot;Fast muons&quot;), pch=22,pt.bg=c(col_sp,col_sm,col_fm),pt.cex=1.5,cex=1,bg=&quot;white&quot;) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
